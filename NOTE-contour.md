# NOTE-contour.md - 等値線アルゴリズム

いちどキチンと考えておく。

## Marching Squares アルゴリズム

https://en.wikipedia.org/wiki/Marching_squares

* 等値線を引くべきすべての値について、
* 与えられた二次元配列のすべてのセル（隣接する4点が囲む矩形）について、
* セルの4つの角をチェックして、等値面を超えているかを調べる
* このとき等号は不便（場合分けが増える）なので微小値増加させる（※）
* 4つの真偽値を組み合わせると16通りの場合分けができる (後述)
* それぞれの場合についてセルの各辺と等値線の交点を（通常は線形補間により）求め、線分を描画する
* 二本の線が引かれるべき２通りについては、交差または二種類の鞍部が選べるが、4つの角の値の平均により鞍部の２種類を描き分けるアイデアがある

※  次書はデータの最大値と最小値の差に 1.e-6 を乗じた程度のεを加算することを提案している
塩野清治 [ほか]著. BASICによるコンターマップ, 共立出版, 1988.11. 4-320-04620-X. https://ndlsearch.ndl.go.jp/books/R100000002-I000001951814

各セルについていきなり線を描画せず、
ひとつなぎの折線を構成する線分たちを集めてから描画する場合がある。

橋本典明、高橋智晴: 2.多量データを対象とする等値線自動描画アルゴリズムの開発.
国土交通省港湾技術研究所 編『港湾技術研究所報告』22(2),国土交通省港湾技術研究所,1983-06. 国立国会図書館デジタルコレクション https://dl.ndl.go.jp/pid/3215914 (参照 2025-01-28)

そうする現代的な意義は次であろう。

* 見栄えのためにスプラインなどの曲線を描く場合: これは補間でも対処できる (後述)
* PostScript など折線に適した中間データを用いる場合のファイル最小化
* 線分に等値線の値を書き加えるための把握 （割愛してもできなくはない）

折線の長さは予測困難であり、メモリ管理も面倒なので、選びたくない。

## 補間や間引き

データが多すぎる場合は、間引きをしたほうが、描画処理の高速化をしつつ、
画質は劣化させない、または多すぎる線によって読み取りが困難になるのを防ぐことができる。

データが少なすぎて描画が粗くなる場合、次の対処がありうる

* 折線を集めてからスプラインなどの曲線を描画する
* データを補間してから等値線描画ロジックにかける

データを補間したほうが心配が少ない。スプライン補間の挙動は保証が難しく、多数の等値線が集中するような場所では異なる値の等値線が交差してしまうことが発生しないとは保証できない。

気象庁の FAX 図用の FORTRAN ルーチンでは 301x301 格子の配列に間引きまたは補間している。
すなわち、302 格子以上であれば 1/2 に間引きし、603 格子以上であれば 1/3 に間引きし、 904 格子以上であれば 1/4 に間引きする。
いっぽうで 150 格子以下であれば 2 倍に引き伸ばして間を補間し、100 格子以下であれば 3 倍に引き伸ばして間を補間してゆく。
これにより等値線ロジックは 151..301 格子を入力とすることが保証される。
ざっくり 200 格子程度である。

FAX 図は縦横 2000px 程度の画像である。200 格子程度で等値線を描くということは、
格子間隔はおおむね 100px 程度。
等値線の幅は 2-5px 程度なので、線分の典型的長さは幅の 30 倍程度となる。
常に滑らかにできるわけではないが、滑らかなところではスプラインを使っても効果がない程度であり、しかもたとえば前線などの滑らかにすべきでないところもあるので、結局この程度で良いのだろうと思う。

補間は線形では無意味である。周縁1セルを除いてはキュービック補間がよいだろう。
普通にラグランジュ補間すればいい。

簡単のため1次元について、座標値 x(i) = x0 + i * dx について
関数値 z[i-1], z[i], z[i+1], z[i+2] が与えられるとき、
任意の座標 x に対する補間関数値は r = (x - x0) / dx - (float)i とすると

fm1 = (r-0)\*(r-1)\*(r-2) / (((-1)-0)\*((-1)-1)\*((-1)-2))
 = r\*(r-1)\*(r-2) / -6.0

f0  = (r-(-1))\*(r-1)\*(r-2) / ((0-(-1))\*(0-1)\*(0-2))
 = (r+1)\*(r-1)\*(r-2) / 2.0

f1  = (r-(-1))\*(r-0)\*(r-2) / ((1-(-1))\*(1-0)\*(1-2))
 = (r+1)\*r\*(r-2) / -2.0

f2  = (r-(-1))\*(r-0)\*(r-1) / ((2-(-1))\*(2-0)\*(2-1))
 = (r+1)\*r\*(r-1) / 6.0

として

z = fm1\*z[i-1] + f0\*z[i] + f1\*z[i+1] + f2\*z[i+2]


## 場合分け

TBD
